<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Service Coverage Planner</title>

  <!-- Leaflet + Leaflet.draw + Turf -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --panel:#11162a; --muted:#96a0b5; --text:#e5e7eb; --accent:#7dd3fc;
      --card:#0f152a; --border:#1f2a44;
    }
    *{box-sizing:border-box}
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    .app { display:flex; height:100%; width:100%; }

    .sidebar { width:420px; max-width:46vw; background:var(--panel); border-right:1px solid var(--border);
      display:flex; flex-direction:column; padding:16px 14px; gap:12px; overflow:auto; }
    .brand { display:flex; align-items:center; gap:10px; }
    .brand .logo { width:28px; height:28px; border-radius:8px; background:linear-gradient(135deg, var(--accent), #60a5fa); display:inline-block; }
    .brand h1 { font-size:16px; margin:0; letter-spacing:0.3px; }
    .tiny { color:var(--muted); font-size:12px; }
    .section-title { font-size:12px; letter-spacing:.08em; text-transform:uppercase; color:#b6c2db; margin:10px 2px 2px; }
    .panel { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:10px 12px; display:flex; flex-direction:column; gap:8px; }
    .row { display:flex; gap:8px; }
    .row input, .row textarea, .row select {
      width:100%; padding:8px 10px; border-radius:8px; border:1px solid var(--border); outline:none;
      background:#0e1430; color:#e5e7eb;
    }
    textarea { min-height:62px; resize:vertical; }
    .list { display:flex; flex-direction:column; gap:8px; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:10px 12px; display:flex; flex-direction:column; gap:8px; }
    .card.active { outline:2px solid var(--accent); }
    .item-header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .item-name { font-weight:600; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; }
    .btn { padding:6px 10px; border-radius:8px; border:1px solid var(--border); background:#121a34; color:#e5e7eb; cursor:pointer; font-size:12px; }
    .btn:hover{ border-color:#2a3a62; background:#0e1530; }
    .btn-primary { background:linear-gradient(135deg,#38bdf8,#60a5fa); color:#0b1020; border:none; }
    .btn-danger { background:#1a0f12; border-color:#3a1620; color:#fecaca; }

    .zip-list { display:flex; flex-wrap:wrap; gap:6px; }
    .zip-pill { padding:4px 6px; border-radius:999px; background:#0e1430; border:1px solid var(--border); color:#e9edf5; font-size:12px; }

    .main { flex:1; display:flex; flex-direction:column; }
    .topbar { height:56px; display:flex; align-items:center; justify-content:space-between; padding:0 16px; border-bottom:1px solid var(--border); background:var(--panel); }
    .topbar .title { font-size:14px; font-weight:600; }
    .topbar .tools { display:flex; gap:10px; }
    .topbar .tools .btn { background:#101831; }

    .content { position:relative; flex:1; display:flex; }
    #map { flex:1; }

    .selection-panel {
      position:absolute; top:10px; right:10px; z-index:9999; background:rgba(17,22,42,0.96);
      border:1px solid var(--border); padding:12px; border-radius:12px; width:340px; max-height:70vh; overflow:auto;
      box-shadow:0 10px 30px rgba(0,0,0,0.45);
    }
    .selection-panel h3 { margin:0 0 8px 0; font-size:14px; }
    .selection-panel .small { color:var(--muted); font-size:12px; margin-bottom:6px; }
    .selection-panel ul { margin:8px 0 0 16px; padding:0; font-size:12px; }
    .selection-panel .btn { margin-top:8px; }

    #busy { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(17,22,42,0.96); border:1px solid var(--border); padding:10px 12px; border-radius:10px;
      z-index:10000; display:none; box-shadow:0 10px 30px rgba(0,0,0,.45) }

    .leaflet-control-layers { background:#0f152a !important; color:#e5e7eb !important; border:1px solid var(--border) !important; }
    .leaflet-container { background:#0a0f1f; }
    .leaflet-bar a, .leaflet-bar a:hover { background:#111a34; color:#fff; border-bottom:1px solid var(--border); }
    .leaflet-draw-toolbar { box-shadow:0 6px 18px rgba(0,0,0,.35); border-radius:8px; overflow:hidden; }
    .leaflet-draw-toolbar a { background:#111a34 !important; border:1px solid var(--border) !important; color:#e5e7eb !important; }
    .leaflet-draw-toolbar a:hover { background:#0e1530 !important; border-color:#2a3a62 !important; }

    .leaflet-marker-icon.tech-center-label { width:auto !important; height:auto !important; }
    .tech-center-label, .tech-center-label * { pointer-events: none; }
    .tech-pill { display:inline-block; font-size:12px; font-weight:700; padding:2px 8px; border-radius:999px; background:rgba(10,15,25,0.85); color:#fff; border:2px solid currentColor; box-shadow:0 0 0 2px rgba(255,255,255,0.70); white-space:nowrap; }

    /* Distinct Area label style (flag) */
    .area-center-label, .area-center-label * { pointer-events:none; }
    .area-label-flag {
      display:inline-block;
      padding:3px 10px;
      border:2px solid currentColor;
      border-radius:6px;
      font-size:11px;
      font-weight:600;
      letter-spacing:0.3px;
      text-align:center;
      white-space:nowrap;
      box-shadow:0 0 6px rgba(0,0,0,0.45);
      transform:translateY(-2px);
      background:rgba(10,15,25,0.88);
    }
    .area-label-text { font-style:italic; color:inherit; }

    .legend { position:absolute; bottom:10px; left:10px; z-index:9999; background:rgba(17,22,42,0.96); border:1px solid var(--border); border-radius:10px; padding:8px 10px; font-size:12px; }
    .legend .row { display:flex; align-items:center; gap:6px; margin-top:4px; }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <div class="brand">
        <span class="logo"></span>
        <h1>Service Coverage Planner</h1>
      </div>
      <div class="tiny">Manage labeled <b>Areas</b> (ZIP sets). Assign one or more Areas to each technician. <b>Areas are always visible.</b></div>

      <!-- AREAS -->
      <div class="section-title">Areas</div>
      <div class="panel">
        <div class="row">
          <input id="newAreaName" placeholder="New Area name (e.g., North Route)" />
          <button id="createArea" class="btn-primary btn">Create</button>
        </div>
        <div class="tiny">Click <b>Edit</b> to toggle ZIPs (or use rectangle for bulk add/remove). Areas follow ZIP boundaries.</div>
      </div>
      <div id="areasList" class="list"></div>

      <!-- TECHNICIANS -->
      <div class="section-title">Technicians</div>
      <div class="panel">
        <div class="row"><input id="addName" placeholder="Technician name" /></div>
        <div class="row"><input id="addContact" placeholder="Contact (optional)" /></div>
        <div class="row"><textarea id="addNotes" placeholder="Notes (optional)"></textarea></div>
        <div class="row"><input id="addTags" placeholder="Tags (comma or space separated)" /></div>
        <div class="row">
          <button id="addTech" class="btn-primary btn">Add Technician</button>
          <div id="addMsg" class="tiny"></div>
        </div>
      </div>
      <div class="row"><input id="techSearch" placeholder="Search technicians or ZIPs..." /></div>
      <div id="techList" class="list"></div>
    </aside>

    <section class="main">
      <div class="topbar">
        <div class="title">Illinois & Indiana ZIP Coverage (USPS-aligned)</div>
        <div class="tools">
          <button id="clearAll" class="btn">Clear Highlights</button>
          <button id="toggleLabels" class="btn">Toggle ZIP Labels</button>
          <button id="toggleAllTerritories" class="btn">Show All Territories</button>
          <button id="toggleOverlaps" class="btn">Highlight Overlaps</button>
          <button id="resetData" class="btn">Reset Demo Data</button>
        </div>
      </div>

      <div class="content">
        <div id="map"></div>

        <div class="selection-panel" id="selectionPanel" hidden>
          <h3>Selected ZIPs</h3>
          <div class="small">Drag a rectangle to list ZIPs.<br/>If editing an Area, rectangle performs bulk add/remove.</div>
          <ul id="zipList"></ul>
          <div class="row">
            <button id="copyZips" class="btn">Copy ZIPs</button>
            <button id="clearSelection" class="btn">Clear</button>
          </div>
          <div id="copyMsg" class="tiny"></div>
        </div>

        <div id="busy">
          <span style="display:inline-block;width:6px;height:6px;background:#7dd3fc;border-radius:50%;margin:0 2px;animation:bl 1.2s infinite"></span>
          <span style="display:inline-block;width:6px;height:6px;background:#7dd3fc;border-radius:50%;margin:0 2px;animation:bl 1.2s infinite .15s"></span>
          <span style="display:inline-block;width:6px;height:6px;background:#7dd3fc;border-radius:50%;margin:0 2px;animation:bl 1.2s infinite .3s"></span>
          <span id="busyMsg" style="margin-left:6px">Processing…</span>
        </div>

        <div class="legend" id="legendBox">
          <div><span style="display:inline-block;width:10px;height:10px;background:#8ecae6;border:1px solid #1d3557;margin-right:6px;"></span>ZIP polygons</div>
          <div><span style="display:inline-block;width:10px;height:3px;background:#999;margin-right:6px;"></span>Area outlines (always visible)</div>
          <div><span style="display:inline-block;width:10px;height:3px;background:#ff6d00;margin-right:6px;"></span>Per-ZIP edges (selection)</div>
          <div><span style="display:inline-block;width:10px;height:3px;background:#7dd3fc;margin-right:6px;"></span>Focus outline (Area/Tech)</div>
          <div id="areasLegendRows" style="margin-top:6px;font-weight:600">Areas</div>
          <div id="territoryLegendRows" style="margin-top:6px;font-weight:600"></div>
          <div id="overlapLegendRow" style="margin-top:6px;"></div>
          <div class="tiny" style="margin-top:6px;opacity:.85">When multiple techs share boundaries, their colored borders are <b>inset</b> (stacked) so all colors are visible.</div>
        </div>
      </div>
    </section>
  </div>

  <script>
  // ----------------- Storage & Seed Data -----------------
  const STORAGE_TECHS = "svc_techs_v11_assign_areas";
  const STORAGE_AREAS = "svc_areas_v7_zipsets";

  const DEFAULT_TECHS = [
    { id: 1, name: "Alex Rivera",  contact: "(312) 555-0142", notes:"", tags:[], areaIds:[1001] },
    { id: 2, name: "Morgan Patel", contact: "(219) 555-0184", notes:"", tags:[], areaIds:[1002] },
    { id: 3, name: "Sam Chen",     contact: "(773) 555-0111", notes:"", tags:[], areaIds:[1003] }
  ];
  const DEFAULT_AREAS = [
    { id: 1001, name: "Southwest Burbs", zips: ["60452","60453","60462","60463","60477"] },
    { id: 1002, name: "NW Indiana Core", zips: ["46307","46373","46375","46385"] },
    { id: 1003, name: "South Loop + Midway", zips: ["60608","60616","60609","60632","60623","60638"] }
  ];

  let TECHS = [];
  let AREAS = [];

  function loadAll(){
    try{ const t = JSON.parse(localStorage.getItem(STORAGE_TECHS)||"null"); TECHS = Array.isArray(t)? t : DEFAULT_TECHS; }catch{ TECHS=DEFAULT_TECHS; }
    try{ const a = JSON.parse(localStorage.getItem(STORAGE_AREAS)||"null"); AREAS = Array.isArray(a)? a : DEFAULT_AREAS; }catch{ AREAS=DEFAULT_AREAS; }
  }
  function saveTechs(){ try{ localStorage.setItem(STORAGE_TECHS, JSON.stringify(TECHS)); }catch{} }
  function saveAreas(){ try{ localStorage.setItem(STORAGE_AREAS, JSON.stringify(AREAS)); }catch{} }
  function resetDemo(){ TECHS = JSON.parse(JSON.stringify(DEFAULT_TECHS)); AREAS = JSON.parse(JSON.stringify(DEFAULT_AREAS)); saveTechs(); saveAreas(); renderAll(); rebuildAllAreas(true); if(allTerritoriesOn){ rebuildAllTerritories(true); if (overlapOn) rebuildOverlaps(true);} }

  // ----------------- Map & Panes -----------------
  const map = L.map("map", { zoomSnap:0.5 }).setView([41.5,-88.0], 8);
  L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", { attribution:'&copy; OSM & CARTO' }).addTo(map);

  map.createPane('areasPane');            map.getPane('areasPane').style.zIndex = 360;
  map.createPane('territoriesPane');      map.getPane('territoriesPane').style.zIndex = 420; // ABOVE areas
  map.createPane('territoriesLabelPane'); map.getPane('territoriesLabelPane').style.zIndex = 440;
  map.createPane('overlapsPane');         map.getPane('overlapsPane').style.zIndex = 460; // ABOVE territories
  map.createPane('baseZipPane');          map.getPane('baseZipPane').style.zIndex = 340;
  map.createPane('selectionPane');        map.getPane('selectionPane').style.zIndex = 450;
  map.createPane('focusPane');            map.getPane('focusPane').style.zIndex = 500;
  map.createPane('labelPane');            map.getPane('labelPane').style.zIndex = 520;
  // NEW: dedicated high-priority pane for area labels so they never sit under lines
  map.createPane('areaLabelsPane');       map.getPane('areaLabelsPane').style.zIndex = 530;

  // Palettes
  const TECH_COLORS  = ["#e11d48","#22c55e","#3b82f6","#a855f7","#f59e0b","#ec4899","#14b8a6","#f97316","#84cc16","#06b6d4","#8b5cf6","#ef4444"];
  const AREA_COLORS  = ["#54d2a3","#f59e0b","#60a5fa","#f43f5e","#8b5cf6","#22c55e","#f97316","#06b6d4","#84cc16","#eab308","#e879f9","#94a3b8"];

  // ZIP base layer
  const zipLayer = L.geoJSON(null, {
    pane: 'baseZipPane',
    style: () => ({ fillColor:"#8ecae6", color:"#2b344d", weight:0.6, fillOpacity:0.10 }),
    onEachFeature: (f, layer) => {
      const p = f.properties;
      layer.bindTooltip(`<b>${p.zip}</b> — ${p.city}, ${p.STATE}`, {direction:"top"});
      layer.on('click', () => {
        if (!AREA_EDIT_CTX.active) return;
        const z = String(p.zip||""); if(!z) return;
        const set = new Set(AREA_EDIT_CTX.area.zips);
        if (set.has(z)) { set.delete(z); toast(`Removed ${z} from ${AREA_EDIT_CTX.area.name}`); }
        else { set.add(z); toast(`Added ${z} to ${AREA_EDIT_CTX.area.name}`); }
        AREA_EDIT_CTX.area.zips = Array.from(set).sort();
        postAreaChange(AREA_EDIT_CTX.area);
      });
    }
  }).addTo(map);

  // Focus overlays (for View Area / View Territory)
  const focusFill    = L.geoJSON(null, { pane:'focusPane', interactive:false, style:{ color:"#13293d", weight:0, fillColor:"#13293d", fillOpacity:0.12 } }).addTo(map);
  const focusHalo    = L.geoJSON(null, { pane:'focusPane', interactive:false, style:{ color:"#ffffff", weight:8, opacity:0.95, fillOpacity:0 } }).addTo(map);
  const focusOutline = L.geoJSON(null, { pane:'focusPane', interactive:false, style:{ color:"#0ea5e9", weight:4, opacity:1, fillOpacity:0 } }).addTo(map);
  let focusLabel = null;

  // Selection overlays
  const selPerZipEdges = L.geoJSON(null, { pane:'selectionPane', interactive:false, style:{ color:"#ff6d00", weight:3, fillOpacity:0 } }).addTo(map);
  const selFill        = L.geoJSON(null, { pane:'selectionPane', interactive:false, style:{ color:"#7dd3fc", weight:0, fillColor:"#7dd3fc", fillOpacity:0.05 } }).addTo(map);
  const selHalo        = L.geoJSON(null, { pane:'selectionPane', interactive:false, style:{ color:"#ffffff", weight:7, opacity:0.85 } }).addTo(map);
  const selOutline     = L.geoJSON(null, { pane:'selectionPane', interactive:false, style:{ color:"#7dd3fc", weight:3, opacity:1 } }).addTo(map);
  let selectionLabel = null;

  // Always-visible AREAS overlay + labels (labels on their own pane)
  const allAreasOverlays = L.layerGroup([], { pane:'areasPane' }).addTo(map);
  const allAreasLabels   = L.layerGroup([], { pane:'areaLabelsPane' }).addTo(map);

  // Toggleable TECH territories + labels
  const allTerritoriesOverlays = L.layerGroup([], { pane:'territoriesPane' });
  const allTerritoriesLabels   = L.layerGroup([], { pane:'territoriesLabelPane' });
  let allTerritoriesOn = false;

  // Overlap layer (above territories)
  const overlapLayer = L.layerGroup([], { pane:'overlapsPane' });
  let overlapOn = false;

  // ZIP labels toggle
  const labelsLayer = L.layerGroup([], { pane:'labelPane' }).addTo(map);
  let labelsBuilt=false, labelsEnabled=false;
  function buildLabels(){
    if (labelsBuilt) return; labelsBuilt=true;
    zipLayer.eachLayer(l=>{
      const f=l.feature; if(!f) return;
      const c=turf.centerOfMass(f).geometry.coordinates;
      const icon=L.divIcon({ className:"zip-label", html:`<div style="font-size:10px;color:#0b132b;text-shadow:0 0 2px #fff">${f.properties.zip}</div>` });
      labelsLayer.addLayer(L.marker([c[1],c[0]],{icon, pane:'labelPane'}));
    });
  }
  const LABEL_ZOOM=12;
  function syncLabels(){ if(map.getZoom()>=LABEL_ZOOM && labelsEnabled){ buildLabels(); if(!map.hasLayer(labelsLayer)) map.addLayer(labelsLayer);} else { if(map.hasLayer(labelsLayer)) map.removeLayer(labelsLayer);} }
  map.on("zoomend", syncLabels);
  document.getElementById("toggleLabels").addEventListener("click",()=>{ labelsEnabled=!labelsEnabled; syncLabels(); });

  // Rectangle draw
  const selectionDraw = new L.Control.Draw({
    draw: { polygon:false, polyline:false, circle:false, marker:false, circlemarker:false,
      rectangle: { shapeOptions: { color:"#7dd3fc", weight:2 } } },
    edit: false
  });
  map.addControl(selectionDraw);

  // ----------------- Data Load -----------------
  const BASE = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_ZIP_Code_Areas_anaylsis/FeatureServer/0/query";
  const IL_URL = BASE + "?where=STATE%20%3D%20'IL'&outFields=ZIP_CODE,PO_NAME,STATE&outSR=4326&f=geojson";
  const IN_URL = BASE + "?where=STATE%20%3D%20'IN'&outFields=ZIP_CODE,PO_NAME,STATE&outSR=4326&f=geojson";
  function normalizeFeature(f){ const p=f.properties||{}; f.properties={ zip:p.zip||p.ZIP_CODE||"", city:p.city||p.PO_NAME||"", STATE:p.STATE||p.state||"" }; return f; }

  let zipIndex = new Map();

  async function loadData(){
    const [il,_in] = await Promise.all([fetch(IL_URL).then(r=>r.json()), fetch(IN_URL).then(r=>r.json())]);
    const features = [...(il.features||[]), ...(_in.features||[])].map(normalizeFeature);
    zipLayer.addData({ type:"FeatureCollection", features });
    zipLayer.eachLayer(l => { const z=String(l.feature.properties.zip||""); if(z) zipIndex.set(z,l); });
    const b = zipLayer.getBounds(); if (b.isValid()) map.fitBounds(b,{padding:[20,20]});

    loadAll();
    renderAll();
    rebuildAllAreas(true); // areas are always visible
  }
  loadData().catch(console.error);

  // ----------------- Helpers -----------------
  const INSET_STEP_KM = 0.18; // ~180m inward per stacked outline
  function showBusy(msg){ const el=document.getElementById('busy'); const m=document.getElementById('busyMsg'); if(m) m.textContent=msg||'Processing…'; if(el) el.style.display='block'; }
  function hideBusy(){ const el=document.getElementById('busy'); if(el) el.style.display='none'; }
  function toast(msg){
    const t=document.createElement('div'); t.className='toast'; t.textContent=msg;
    Object.assign(t.style,{position:'absolute',right:'12px',bottom:'12px',zIndex:10001,background:'#0f152a',border:'1px solid var(--border)',color:'#e5e7eb',padding:'8px 10px',borderRadius:'10px',fontSize:'12px'});
    document.body.appendChild(t); setTimeout(()=>t.remove(),1400);
  }
  function dimBaseZips(){ zipLayer.setStyle({ color:"#3b4766", weight:0.4, fillOpacity:0.06 }); }
  function restoreBaseZips(){ zipLayer.setStyle({ color:"#2b344d", weight:0.6, fillOpacity:0.10 }); refreshZipStyles(); }

  function featuresForZips(zips){
    const feats=[]; (zips||[]).forEach(z=>{ const l=zipIndex.get(String(z)); if(l) feats.push(l.feature); });
    return feats;
  }

  // Robust union
  function unionOfFeatures(feats){
    if (!feats || !feats.length) return null;
    const list = feats.slice();
    function safeUnion(a, b){ try { return turf.union(a, b); } catch { return a || b; } }
    const CHUNK = 25, chunks=[];
    for (let i=0;i<list.length;i+=CHUNK){ let acc=list[i]; for(let j=i+1;j<Math.min(i+CHUNK,list.length);j++){ acc=safeUnion(acc,list[j]); } chunks.push(acc); }
    let u = chunks[0]; for (let k=1;k<chunks.length;k++){ u=safeUnion(u,chunks[k]); }
    try { if (turf.cleanCoords) u=turf.cleanCoords(u); } catch {}
    try { u=turf.simplify(u,{tolerance:0.001, highQuality:true}); } catch {}
    return u || null;
  }

  // -------------- SVG Pattern Utilities (cross-hatch) --------------
  function ensureSvgDefs(){
    const pane = map.getPane('overlayPane') || map.getPane('focusPane') || map.getPane('areasPane');
    const svgs = (pane || document).getElementsByTagName('svg');
    const svg = svgs[0];
    if (!svg) return null;
    let defs = svg.querySelector('defs');
    if (!defs){ defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
    return defs;
  }

  function makeHatchPattern(id, color, spacing=8, strokeWidth=1){
    const defs = ensureSvgDefs(); if(!defs) return;
    const old = document.getElementById(id); if(old) old.remove();

    const pattern = document.createElementNS('http://www.w3.org/2000/svg','pattern');
    pattern.setAttribute('id', id);
    pattern.setAttribute('patternUnits','userSpaceOnUse');
    pattern.setAttribute('width', spacing);
    pattern.setAttribute('height', spacing);

    const line1 = document.createElementNS('http://www.w3.org/2000/svg','path');
    line1.setAttribute('d', `M 0 0 L ${spacing} ${spacing}`);
    line1.setAttribute('stroke', color);
    line1.setAttribute('stroke-opacity', '0.35');
    line1.setAttribute('stroke-width', String(strokeWidth));

    const line2 = document.createElementNS('http://www.w3.org/2000/svg','path');
    line2.setAttribute('d', `M ${spacing} 0 L 0 ${spacing}`);
    line2.setAttribute('stroke', color);
    line2.setAttribute('stroke-opacity', '0.35');
    line2.setAttribute('stroke-width', String(strokeWidth));

    pattern.appendChild(line1);
    pattern.appendChild(line2);
    defs.appendChild(pattern);
  }

  function applyHatchToLayerGroup(layerGroup, patternId, baseColor="#13293d"){
    layerGroup.eachLayer(l=>{
      if (l && l._path){
        l._path.setAttribute('fill', `url(#${patternId})`);
        l._path.setAttribute('fill-opacity', '1');
        try { l.setStyle({ fillColor: baseColor, fillOpacity: 0.03 }); } catch {}
      }
    });
  }

  // ----------------- Focus Rendering -----------------
  const cache = { areaUnion:new Map(), techUnion:new Map() };

  function areaUnion(area){
    const key = `${area.id}:${(area.zips||[]).join(',')}`;
    if (cache.areaUnion.has(key)) return cache.areaUnion.get(key);
    const u = unionOfFeatures(featuresForZips(area.zips||[]));
    cache.areaUnion.set(key,u); return u;
  }
  function techUnion(tech){
    const key = `${tech.id}:${(tech.areaIds||[]).join('|')}::${(tech.areaIds||[]).map(id=>AREAS.find(a=>a.id===id)?.zips?.join(',')||'').join('|')}`;
    if (cache.techUnion.has(key)) return cache.techUnion.get(key);
    const feats=[]; (tech.areaIds||[]).forEach(id=>{ const a=AREAS.find(x=>x.id===id); if(a) feats.push(...featuresForZips(a.zips)); });
    const u = unionOfFeatures(feats);
    cache.techUnion.set(key,u); return u;
  }
  function colorForTech(t){ const idx = TECHS.findIndex(x=>x.id===t.id); return TECH_COLORS[idx>=0?idx%TECH_COLORS.length:0]; }
  function colorForArea(a){ const idx = AREAS.findIndex(x=>x.id===a.id); return AREA_COLORS[idx>=0?idx%AREA_COLORS.length:0]; }

  function clearFocus(){
    focusFill.clearLayers(); focusHalo.clearLayers(); focusOutline.clearLayers();
    if (focusLabel){ map.removeLayer(focusLabel); focusLabel=null; }
  }
  function clearSelection(){
    selPerZipEdges.clearLayers(); selFill.clearLayers(); selHalo.clearLayers(); selOutline.clearLayers();
    if (selectionLabel){ map.removeLayer(selectionLabel); selectionLabel=null; }
  }

  function renderFocusFeature(u, labelText, color, useHatch=false){
    clearSelection(); clearFocus();
    if (!u) { restoreBaseZips(); return; }

    focusFill.setStyle({ color:"#13293d", fillColor:"#13293d", weight:0, fillOpacity:0.12 });
    focusFill.addData(u);

    if (useHatch){
      const pid = `focus-hatch-${color.replace('#','')}`;
      makeHatchPattern(pid, color, 8, 1.25);
      applyHatchToLayerGroup(focusFill, pid, "#13293d");
    }

    try { const line=turf.polygonToLine(u); focusHalo.addData(line); focusOutline.setStyle({ color: color, weight:4, opacity:1, lineJoin:'round' }); focusOutline.addData(line); }
    catch { focusHalo.addData(u); focusOutline.setStyle({ color: color, weight:4, opacity:1, lineJoin:'round' }); focusOutline.addData(u); }

    try {
      const c=turf.centerOfMass(u).geometry.coordinates;
      const icon=L.divIcon({ className:"tech-center-label", iconSize:null, html:`<div class="tech-pill" style="color:${color}">${labelText}</div>` });
      focusLabel=L.marker([c[1],c[0]],{icon, pane:'focusPane'}).addTo(map);
    } catch {}
    dimBaseZips();
    let b=focusOutline.getBounds(); if(!b||!b.isValid()){ try{ b=focusFill.getBounds(); }catch{} } if(b&&b.isValid()) map.fitBounds(b,{padding:[20,20]});
  }

  // ----------------- Selection Panel -----------------
  const selectionPanel = document.getElementById("selectionPanel");
  const zipListEl = document.getElementById("zipList");
  const copyZipsBtn = document.getElementById("copyZips");
  const clearSelectionBtn = document.getElementById("clearSelection");
  const copyMsg = document.getElementById("copyMsg");
  let lastSelectionZips = [];

  copyZipsBtn.addEventListener("click", async ()=>{
    if (!lastSelectionZips.length){ copyMsg.textContent="No ZIPs."; return; }
    try{ await navigator.clipboard.writeText(lastSelectionZips.join(",")); copyMsg.textContent=`Copied ${lastSelectionZips.length} ZIPs.`; }
    catch{ copyMsg.textContent="Copy failed."; }
  });
  clearSelectionBtn.addEventListener("click", ()=>{
    selectionPanel.hidden=true; lastSelectionZips=[]; copyMsg.textContent="";
    clearSelection(); restoreBaseZips();
  });

  const AREA_EDIT_CTX = { active:false, area:null, mode:"add" }; // "add"|"remove"

  map.on(L.Draw.Event.CREATED, e=>{
    if (e.layerType!=="rectangle") return;
    const b = e.layer.getBounds();
    const rectPoly = turf.polygon([[
      [b.getWest(), b.getSouth()],
      [b.getEast(), b.getSouth()],
      [b.getEast(), b.getNorth()],
      [b.getWest(), b.getNorth()],
      [b.getWest(), b.getSouth()]
    ]]);
    const hits=[];
    zipLayer.eachLayer(l=>{
      const f=l.feature; const bb=l.getBounds?.();
      if (bb && (bb.getEast()<b.getWest() || bb.getWest()>b.getEast() || bb.getNorth()<b.getSouth() || bb.getSouth()>b.getNorth())) return;
      try{ if (turf.booleanIntersects(f,rectPoly)) hits.push(f); }catch{}
    });
    const zips = Array.from(new Set(hits.map(h=>h.properties.zip))).sort();

    if (AREA_EDIT_CTX.active) {
      const set = new Set(AREA_EDIT_CTX.area.zips);
      if (AREA_EDIT_CTX.mode==="remove"){ zips.forEach(z=>set.delete(z)); }
      else { zips.forEach(z=>set.add(z)); }
      AREA_EDIT_CTX.area.zips = Array.from(set).sort();
      postAreaChange(AREA_EDIT_CTX.area);
      toast(`${AREA_EDIT_CTX.mode==="remove"?"Removed":"Added"} ${zips.length} ZIPs for ${AREA_EDIT_CTX.area.name}`);
      return;
    }

    // Normal selection panel display
    zipListEl.innerHTML="";
    zips.forEach(z=>{
      const f=zipIndex.get(z)?.feature?.properties;
      const li=document.createElement("li"); li.textContent = f? `${f.zip} — ${f.city} (${f.STATE})` : z;
      zipListEl.appendChild(li);
    });
    lastSelectionZips = zips;
    selectionPanel.hidden = !zips.length;

    // draw selection overlays
    clearSelection();
    if (zips.length){
      const edgeFeatures=[];
      if (hits.length<=180){ hits.forEach(f=>{ try{ const line=turf.polygonToLine(f); if(line.type==="FeatureCollection") edgeFeatures.push(...line.features); else edgeFeatures.push(line);}catch{} }); selPerZipEdges.addData({type:"FeatureCollection", features:edgeFeatures}); }
      let u=unionOfFeatures(hits);
      selFill.addData(u);
      try{ const line=turf.polygonToLine(u); selHalo.addData(line); selOutline.addData(line); }
      catch{ selHalo.addData(u); selOutline.addData(u); }
      try{ const c=turf.centerOfMass(u).geometry.coordinates; const icon=L.divIcon({ className:"tech-center-label", iconSize:null, html:`<div class='tech-pill' style='color:#7dd3fc'>Selection (${zips.length})</div>` }); selectionLabel=L.marker([c[1],c[0]],{icon, pane:'selectionPane'}).addTo(map);}catch{}
      dimBaseZips();
      const bb = selOutline.getBounds(); if(bb.isValid()) map.fitBounds(bb,{padding:[20,20]});
    }
  });

  // ----------------- UI: Areas -----------------
  const areasListEl = document.getElementById("areasList");
  const newAreaName = document.getElementById("newAreaName");
  document.getElementById("createArea").addEventListener("click", ()=>{
    const nm=(newAreaName.value||"").trim() || "New Area";
    const area = { id: Date.now()+Math.random(), name:nm, zips:[] };
    AREAS.push(area); saveAreas(); newAreaName.value="";
    renderAreas(); setAreaEdit(area, true);
    toast(`Area "${area.name}" created — click ZIPs or drag rectangle to add.`);
    rebuildAllAreas(true);
  });

  function renderAreas(){
    areasListEl.innerHTML="";
    AREAS.forEach(a=>{
      const card=document.createElement("div"); card.className="card";
      if (AREA_EDIT_CTX.active && AREA_EDIT_CTX.area?.id===a.id) card.classList.add("active");
      const head=document.createElement("div"); head.className="item-header";

      const left=document.createElement("div"); left.style.display="flex"; left.style.alignItems="center"; left.style.gap="8px";
      const sw=document.createElement("span"); sw.style.cssText=`display:inline-block;width:12px;height:12px;border-radius:3px;background:${colorForArea(a)};`;
      const nm=document.createElement("span"); nm.className="item-name"; nm.textContent=a.name;
      const meta=document.createElement("span"); meta.className="tiny"; meta.textContent=`${a.zips.length} ZIPs`;
      left.append(sw,nm,meta);

      const actions=document.createElement("div"); actions.className="actions";
      const bView=document.createElement("button"); bView.className="btn"; bView.textContent="View";
      const bEdit=document.createElement("button"); bEdit.className="btn"; bEdit.textContent=(AREA_EDIT_CTX.active && AREA_EDIT_CTX.area?.id===a.id)?"Editing…":"Edit";
      const bCopy=document.createElement("button"); bCopy.className="btn"; bCopy.textContent="Copy ZIPs";
      const bRename=document.createElement("button"); bRename.className="btn"; bRename.textContent="Rename";
      const bDel=document.createElement("button"); bDel.className="btn btn-danger"; bDel.textContent="Delete";
      actions.append(bView,bEdit,bCopy,bRename,bDel);

      head.append(left,actions); card.appendChild(head);

      // edit toolbelt
      const tb=document.createElement("div"); tb.className="row"; tb.style.display=(AREA_EDIT_CTX.active && AREA_EDIT_CTX.area?.id===a.id)?"flex":"none";
      const modeAdd=document.createElement("button"); modeAdd.className="btn"; modeAdd.textContent="Bulk: Add";
      const modeRem=document.createElement("button"); modeRem.className="btn"; modeRem.textContent="Bulk: Remove";
      const hint=document.createElement("div"); hint.className="tiny"; hint.textContent="Click ZIPs to toggle; drag rectangle to bulk add/remove.";
      tb.append(modeAdd,modeRem,hint);
      card.appendChild(tb);

      bView.addEventListener("click", ()=>{ setAreaEdit(null,false); renderAreaFocus(a); });
      bEdit.addEventListener("click", ()=>{
        const activeNow = AREA_EDIT_CTX.active && AREA_EDIT_CTX.area?.id===a.id;
        if (activeNow) setAreaEdit(null,false);
        else setAreaEdit(a,true);
      });
      bCopy.addEventListener("click", ()=> copyToClipboard(a.zips, `${a.name}`));
      bRename.addEventListener("click", ()=>{
        const nn=prompt("Area name:", a.name||"Area"); if(!nn) return;
        a.name=nn.trim(); saveAreas(); renderAreas(); rebuildAllAreas();
        if (focusLabel) renderAreaFocus(a);
      });
      bDel.addEventListener("click", ()=>{
        if(!confirm(`Delete area "${a.name}"?`)) return;
        TECHS.forEach(t=>{ t.areaIds = (t.areaIds||[]).filter(id=>id!==a.id); });
        AREAS = AREAS.filter(x=>x.id!==a.id); saveAreas(); saveTechs();
        setAreaEdit(null,false); clearFocus(); renderAll(); rebuildAllAreas(true); if(allTerritoriesOn){ rebuildAllTerritories(true); if (overlapOn) rebuildOverlaps(true); }
      });
      modeAdd.addEventListener("click", ()=>{ AREA_EDIT_CTX.mode="add"; toast("Bulk mode: Add"); });
      modeRem.addEventListener("click", ()=>{ AREA_EDIT_CTX.mode="remove"; toast("Bulk mode: Remove"); });

      areasListEl.appendChild(card);
    });
  }

  function renderAreaFocus(area){
    const u = areaUnion(area);
    renderFocusFeature(u, area.name, "#0ea5e9", false);
  }

  function setAreaEdit(areaOrNull, enable){
    if (!enable){ AREA_EDIT_CTX.active=false; AREA_EDIT_CTX.area=null; AREA_EDIT_CTX.mode="add"; restoreBaseZips(); renderAreas(); return; }
    AREA_EDIT_CTX.active=true;
    AREA_EDIT_CTX.area=areaOrNull;
    AREA_EDIT_CTX.mode="add";
    renderAreas();
    renderAreaFocus(areaOrNull);
    refreshZipStyles();
  }

  function refreshZipStyles(){
    const edit = AREA_EDIT_CTX.active ? AREA_EDIT_CTX.area : null;
    zipLayer.eachLayer(l=>{
      const z=String(l.feature?.properties?.zip||"");
      if (edit && edit.zips.includes(z)){
        l.setStyle({ fillOpacity:0.28, color:"#2b344d", weight:0.9 });
      } else {
        l.setStyle({ fillOpacity:0.10, color:"#2b344d", weight:0.6 });
      }
    });
  }

  function postAreaChange(area){
    cache.areaUnion.clear(); cache.techUnion.clear();
    saveAreas(); renderAreas(); refreshZipStyles();
    rebuildAllAreas();
    if (allTerritoriesOn) rebuildAllTerritories();
    if (overlapOn) rebuildOverlaps();
    if (focusLabel) renderAreaFocus(area);
  }

  function copyToClipboard(list, label){
    const text=(list||[]).join(",");
    navigator.clipboard.writeText(text).then(()=>toast(`Copied ${list.length} ZIPs for ${label}`)).catch(()=>toast("Copy failed"));
  }

  // ----------------- UI: Techs -----------------
  const techListEl = document.getElementById("techList");
  const techSearch = document.getElementById("techSearch");
  const addName = document.getElementById("addName");
  const addContact = document.getElementById("addContact");
  const addNotes = document.getElementById("addNotes");
  const addTags  = document.getElementById("addTags");
  const addBtn = document.getElementById("addTech");
  const addMsg = document.getElementById("addMsg");

  addBtn.addEventListener("click", ()=>{
    const name=addName.value.trim(); const contact=addContact.value.trim();
    const notes=(addNotes.value||"").trim(); const tags=parseTags(addTags.value);
    if(!name){ addMsg.textContent="Name is required."; return; }
    const id=Date.now()+Math.random(); TECHS.push({id,name,contact,notes,tags,areaIds:[]}); saveTechs();
    addMsg.textContent="Technician added."; addName.value=""; addContact.value=""; addNotes.value=""; addTags.value="";
    renderTechs(); if (allTerritoriesOn) rebuildAllTerritories(true); if (overlapOn) rebuildOverlaps(true);
  });

  function parseTags(text){ const raw=(text||"").trim(); if(!raw) return []; return Array.from(new Set(raw.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean))); }
  function derivedZipsForTech(t){
    const set=new Set();
    (t.areaIds||[]).forEach(id=>{ const a=AREAS.find(x=>x.id===id); (a?.zips||[]).forEach(z=>set.add(z)); });
    return Array.from(set).sort();
  }

  function renderTechs(){
    techListEl.innerHTML="";
    const q=(techSearch.value||"").trim().toLowerCase();
    TECHS.forEach(t=>{
      const zips=derivedZipsForTech(t);
      const matches = !q || t.name.toLowerCase().includes(q) || zips.some(z=>z.includes(q));
      if(!matches) return;

      const card=document.createElement("div"); card.className="card";
      const head=document.createElement("div"); head.className="item-header";

      const left=document.createElement("div"); left.style.display="flex"; left.style.alignItems="center"; left.style.gap="8px";
      const sw=document.createElement("span"); sw.style.cssText=`display:inline-block;width:12px;height:12px;border-radius:3px;background:${colorForTech(t)};`;
      const nm=document.createElement("span"); nm.className="item-name"; nm.textContent=t.name;
      const meta=document.createElement("span"); meta.className="tiny"; meta.textContent=`${zips.length} ZIPs from ${t.areaIds.length} area${t.areaIds.length===1?"":"s"}`;
      left.append(sw,nm,meta);

      const actions=document.createElement("div"); actions.className="actions";
      const bView=document.createElement("button"); bView.className="btn"; bView.textContent="View Territory";
      const bCopy=document.createElement("button"); bCopy.className="btn"; bCopy.textContent="Copy ZIPs";
      const bDel=document.createElement("button"); bDel.className="btn btn-danger"; bDel.textContent="Delete";
      actions.append(bView,bCopy,bDel);

      head.append(left,actions); card.appendChild(head);
      if (t.contact){ const c=document.createElement("div"); c.className="tiny"; c.textContent=t.contact; card.appendChild(c); }
      if (t.notes){ const n=document.createElement("div"); n.className="tiny"; n.textContent=`Notes: ${t.notes}`; card.appendChild(n); }

      const assignRow=document.createElement("div"); assignRow.className="row";
      const sel=document.createElement("select"); sel.multiple=true; sel.size= Math.min(8, Math.max(3, AREAS.length));
      AREAS.forEach(a=>{
        const opt=document.createElement("option"); opt.value=String(a.id); opt.textContent=`${a.name} (${a.zips.length})`;
        if (t.areaIds.includes(a.id)) opt.selected=true;
        sel.appendChild(opt);
      });
      const saveBtn=document.createElement("button"); saveBtn.className="btn-primary btn"; saveBtn.textContent="Save Areas";
      assignRow.append(sel, saveBtn); card.appendChild(assignRow);

      const zipRow=document.createElement("div"); zipRow.className="zip-list";
      zips.slice(0,60).forEach(z=>{ const pill=document.createElement("span"); pill.className="zip-pill"; pill.textContent=z; zipRow.appendChild(pill); });
      if (zips.length>60){ const more=document.createElement("span"); more.className="tiny"; more.textContent=` +${zips.length-60} more`; zipRow.appendChild(more); }
      card.appendChild(zipRow);

      bView.addEventListener("click", ()=>{
        const u=techUnion(t);
        renderFocusFeature(u, t.name, colorForTech(t), true);
      });
      bCopy.addEventListener("click", ()=> copyToClipboard(zips, t.name));
      bDel.addEventListener("click", ()=>{
        if(!confirm(`Delete ${t.name}?`)) return;
        TECHS = TECHS.filter(x=>x.id!==t.id); saveTechs(); renderTechs(); clearFocus(); if(allTerritoriesOn) rebuildAllTerritories(); if (overlapOn) rebuildOverlaps();
      });
      saveBtn.addEventListener("click", ()=>{
        const ids = Array.from(sel.selectedOptions).map(o=>Number(o.value));
        t.areaIds = ids; saveTechs(); cache.techUnion.clear(); renderTechs(); if(allTerritoriesOn) rebuildAllTerritories(true); if (overlapOn) rebuildOverlaps(true);
        toast(`Saved areas for ${t.name}`);
      });

      techListEl.appendChild(card);
    });
  }

  techSearch.addEventListener("input", renderTechs);

  // ----------------- Topbar actions -----------------
  document.getElementById("clearAll").addEventListener("click", ()=>{ setAreaEdit(null,false); clearFocus(); clearSelection(); restoreBaseZips(); });
  document.getElementById("resetData").addEventListener("click", resetDemo);

  const toggleAllBtn = document.getElementById("toggleAllTerritories");
  toggleAllBtn.addEventListener("click", ()=>{
    allTerritoriesOn = !allTerritoriesOn;
    if (allTerritoriesOn){
      rebuildAllTerritories(true);
      map.addLayer(allTerritoriesOverlays);
      map.addLayer(allTerritoriesLabels);
      toggleAllBtn.textContent="Hide All Territories";
      if (overlapOn) rebuildOverlaps(true);
    } else {
      allTerritoriesOverlays.clearLayers();
      allTerritoriesLabels.clearLayers();
      overlapLayer.clearLayers(); map.removeLayer(overlapLayer); overlapOn = false; document.getElementById("toggleOverlaps").textContent="Highlight Overlaps";
      map.removeLayer(allTerritoriesOverlays);
      map.removeLayer(allTerritoriesLabels);
      document.getElementById('territoryLegendRows').innerHTML="";
      document.getElementById('overlapLegendRow').innerHTML="";
      toggleAllBtn.textContent="Show All Territories";
    }
  });

  const toggleOverlapBtn = document.getElementById("toggleOverlaps");
  toggleOverlapBtn.addEventListener("click", ()=>{
    if (!allTerritoriesOn){
      allTerritoriesOn = true;
      rebuildAllTerritories(true);
      map.addLayer(allTerritoriesOverlays);
      map.addLayer(allTerritoriesLabels);
      toggleAllBtn.textContent="Hide All Territories";
    }
    overlapOn = !overlapOn;
    if (overlapOn){
      rebuildOverlaps(true);
      map.addLayer(overlapLayer);
      toggleOverlapBtn.textContent="Hide Overlaps";
    } else {
      overlapLayer.clearLayers(); map.removeLayer(overlapLayer);
      document.getElementById('overlapLegendRow').innerHTML="";
      toggleOverlapBtn.textContent="Highlight Overlaps";
    }
  });

  // ----------------- Always-visible AREAS -----------------
  function rebuildAllAreas(force=false){
    if (force){
      map.removeLayer(allAreasOverlays); map.removeLayer(allAreasLabels);
      allAreasOverlays.clearLayers(); allAreasLabels.clearLayers();
      allAreasOverlays.addTo(map); allAreasLabels.addTo(map);
    } else {
      allAreasOverlays.clearLayers(); allAreasLabels.clearLayers();
    }
    const legend = document.getElementById('areasLegendRows');
    legend.innerHTML = "Areas";
    AREAS.forEach(a=>{
      const u = areaUnion(a); if(!u) return;
      const color = colorForArea(a);

      try{ L.geoJSON(u,{pane:'areasPane', interactive:false, style:{color,weight:2,opacity:0.9,fillColor:color,fillOpacity:0.05}}).addTo(allAreasOverlays); }catch{}

      try{
        const c=turf.centerOfMass(u).geometry.coordinates;
        const icon = L.divIcon({
          className: "area-center-label",
          iconSize: null,
          html: `
            <div class="area-label-flag" style="border-color:${color}">
              <span class="area-label-text" style="color:${color}">${a.name}</span>
            </div>`
        });
        L.marker([c[1],c[0]],{icon, pane:'areaLabelsPane', interactive:false}).addTo(allAreasLabels);
      }catch{}

      const row=document.createElement("div"); row.className="row";
      row.innerHTML=`<span style="display:inline-block;width:12px;height:3px;background:${color};border-radius:2px;"></span><span>${a.name}</span>`;
      legend.appendChild(row);
    });
  }

  // ----------------- Toggleable TERRITORIES with INSET OUTLINES -----------------
  function rebuildAllTerritories(forceBringToFront=false){
    if (!allTerritoriesOn) return;
    if (forceBringToFront){
      map.removeLayer(allTerritoriesOverlays); map.removeLayer(allTerritoriesLabels);
      allTerritoriesOverlays.clearLayers(); allTerritoriesLabels.clearLayers();
      allTerritoriesOverlays.addTo(map); allTerritoriesLabels.addTo(map);
    } else {
      allTerritoriesOverlays.clearLayers(); allTerritoriesLabels.clearLayers();
    }
    const legend = document.getElementById('territoryLegendRows');
    legend.innerHTML = "Territories";

    const techsWithArea = TECHS.filter(t=> (t.areaIds||[]).length>0);
    const ordered = techsWithArea.map((t,i)=>({t, idx:i}));

    ordered.forEach(({t, idx})=>{
      const color = colorForTech(t);
      const u = techUnion(t); if(!u) return;

      // Fill + hatch (darker and above areas)
      let polyGroup=null;
      try{
        polyGroup = L.geoJSON(u,{pane:'territoriesPane', interactive:false, style:{color:"#13293d",weight:0,fillColor:"#13293d",fillOpacity:0.12}});
        polyGroup.addTo(allTerritoriesOverlays);
      }catch{}

      const pid = `tech-hatch-${t.id}`;
      makeHatchPattern(pid, color, 8, 1.25);
      if (polyGroup) applyHatchToLayerGroup(polyGroup, pid, "#13293d");

      // INSET outline = negative buffer by idx * step
      let outlineGeom = null;
      const shrinkKm = Math.max(0, idx) * INSET_STEP_KM;
      try{
        outlineGeom = shrinkKm>0 ? turf.buffer(u, -shrinkKm, {units:'kilometers'}) : u;
        try{ outlineGeom = turf.simplify(outlineGeom,{tolerance:0.0008, highQuality:true}); }catch{}
      }catch{ outlineGeom = u; }

      let outline = null;
      try{ const line=turf.polygonToLine(outlineGeom); outline=L.geoJSON(line,{pane:'territoriesPane', interactive:false, style:{color:color,weight:4,opacity:1,lineJoin:'round'}});}
      catch{ outline=L.geoJSON(outlineGeom,{pane:'territoriesPane', interactive:false, style:{color:color,weight:4,opacity:1,lineJoin:'round'}});}
      outline.addTo(allTerritoriesOverlays);

      // Label
      try{
        const c=turf.centerOfMass(u).geometry.coordinates;
        const icon=L.divIcon({ className:"tech-center-label", iconSize:null, html:`<div class="tech-pill" style="color:${color}">${t.name}</div>` });
        L.marker([c[1],c[0]],{icon, pane:'territoriesLabelPane', interactive:false}).addTo(allTerritoriesLabels);
      }catch{}

      const row=document.createElement("div"); row.className="row";
      row.innerHTML=`<span style="display:inline-block;width:12px;height:3px;background:${color};border-radius:2px;"></span><span>${t.name}</span>`;
      legend.appendChild(row);
    });

    if (overlapOn) rebuildOverlaps();
  }

  // ----------------- Overlap Builder (ZIP-based) -----------------
  function rebuildOverlaps(force=false){
    if (!allTerritoriesOn) return;
    if (force){ map.removeLayer(overlapLayer); overlapLayer.clearLayers(); overlapLayer.addTo(map); }
    else { overlapLayer.clearLayers(); }

    const zipToTechs = new Map();
    TECHS.forEach(t=>{
      const zips = derivedZipsForTech(t);
      zips.forEach(z=>{
        if (!zipToTechs.has(z)) zipToTechs.set(z, []);
        zipToTechs.get(z).push(t.name);
      });
    });

    const overlappingFeatures = [];
    zipLayer.eachLayer(l=>{
      const z = String(l.feature?.properties?.zip||""); if(!z) return;
      const names = zipToTechs.get(z);
      if (names && names.length>=2){
        const f = JSON.parse(JSON.stringify(l.feature));
        f.properties._techNames = names;
        overlappingFeatures.push(f);
      }
    });

    const legend = document.getElementById('overlapLegendRow');
    if (!overlappingFeatures.length){
      legend.innerHTML = "<div class='tiny'>No overlaps detected.</div>";
      return;
    } else {
      legend.innerHTML = `<div class="row"><span style="display:inline-block;width:12px;height:3px;background:#f43f5e;border-radius:2px;"></span><span>Overlap (2+ techs)</span></div>`;
    }

    const overlapColor = "#f43f5e";
    const pid = `overlap-hatch`;
    makeHatchPattern(pid, overlapColor, 6, 1.2);

    const perZipLayer = L.geoJSON({type:"FeatureCollection", features:overlappingFeatures},{
      pane:'overlapsPane',
      interactive:false,
      style:{ color:overlapColor, weight:2, opacity:0.9, fillColor:"#5a1120", fillOpacity:0.18 }
    }).addTo(overlapLayer);

    applyHatchToLayerGroup(perZipLayer, pid, "#5a1120");

    perZipLayer.eachLayer(l=>{
      const names = l.feature?.properties?._techNames||[];
      const z = l.feature?.properties?.zip||"";
      if (names.length){
        l.bindTooltip(`<b>${z}</b><br/>Overlap: ${names.join(", ")}`, {direction:"top", opacity:0.95});
      }
    });

    try{
      const bb = perZipLayer.getBounds();
      if (bb && bb.isValid() && force){ map.fitBounds(bb, { padding:[20,20] }); }
    }catch{}
  }

  // ----------------- Render All -----------------
  function renderAll(){ renderAreas(); renderTechs(); }

  </script>
</body>
</html>
